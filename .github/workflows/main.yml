name: Chained Version Propagation Build

on:
  push:
    paths:
      - 'pom.xml'
    branches:
      - 'release/*'
      - 'master'
  workflow_dispatch:

jobs:
  build-and-propagate:
    runs-on: ubuntu-latest

    steps:
      # 1Ô∏è‚É£ Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ Install necessary tools: xmlstarlet for XML manipulation, jq for JSON parsing
      - name: Install xmlstarlet & jq
        run: sudo apt-get update && sudo apt-get install -y xmlstarlet jq

      # 3Ô∏è‚É£ Extract current project version from pom.xml
      - name: Get current version
        id: version
        run: |
          echo "üîπ Extracting project version from pom.xml"

          # Prefer xmlstarlet (precise)
          if command -v xmlstarlet >/dev/null 2>&1; then
            version=$(xmlstarlet sel -t -v "/_:project/_:version" pom.xml 2>/dev/null || echo "")
          fi

          # Fallback to Maven if xmlstarlet fails
          if [[ -z "$version" ]]; then
            echo "‚ö†Ô∏è xmlstarlet failed, trying Maven help:evaluate"
            version=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout 2>/dev/null || echo "")
          fi

          # Exit if version could not be determined
          if [[ -z "$version" ]]; then
            echo "‚ùå Failed to extract version from pom.xml"
            exit 1
          fi

          echo "‚úÖ Detected version: $version"
          echo "version=$version" >> $GITHUB_OUTPUT

      # 4Ô∏è‚É£ Build the current project to ensure correctness
      - name: Build project
        run: mvn clean install

      # 5Ô∏è‚É£ Setup Git configuration for commits in dependent repos
      - name: Setup Git
        run: |
          git config --global user.name "ci-user"
          git config --global user.email "ci-user@example.com"

      # 6Ô∏è‚É£ Load dependents list from dependencies.json
      - name: Load dependents from JSON
        id: deps
        run: |
          # Extract dependents (if none, this will be empty)
          dependents=$(jq -r '.dependents[]?' dependencies.json | xargs)
          echo "dependents=$dependents" >> $GITHUB_OUTPUT

      # 7Ô∏è‚É£ Loop through each dependent repo and update versions (fixed)
      - name: Update dependent repos
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
          VERSION: ${{ steps.version.outputs.version }}
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail

          for repo in ${{ steps.deps.outputs.dependents }}
          do
            echo "üîπ Processing dependent repo: $repo"

            # Clone dependent repository using PAT token
            git clone https://x-access-token:${GH_TOKEN}@github.com/chetanpatil018/$repo.git
            cd $repo || { echo "‚ùå Failed to enter repo $repo"; exit 1; }

            # Ensure the branch exists; if not, create and push it
            if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
              git checkout "$BRANCH_NAME"
              git pull --ff-only
            else
              git checkout -b "$BRANCH_NAME"
              git push origin "$BRANCH_NAME"
            fi

            # Skip repos without pom.xml
            if [[ ! -f pom.xml ]]; then
              echo "‚ùå pom.xml not found in $repo"
              cd ..
              rm -rf $repo
              continue
            fi

            # Update parent version in pom.xml (this is correct)
            echo "üîß Updating parent version in $repo to $VERSION"
            xmlstarlet ed -L -u "/_:project/_:parent/_:version" -v "$VERSION" pom.xml || echo "‚ö†Ô∏è Failed to update parent version"

            # --- IMPORTANT FIX: read the dependent's own dependencies.json (not ../dependencies.json) ---
            if [[ ! -f dependencies.json ]]; then
              echo "‚ö†Ô∏è No dependencies.json in $repo ‚Äî nothing to update here (skipping dependency updates)"
            else
              # Iterate each dependency object safely (one JSON object per line)
              jq -r '.dependencies[]? | "\(.name)|\(.source)"' dependencies.json | while IFS="|" read -r dep_name dep_source; do

                if [[ -z "$dep_name" || -z "$dep_source" || "$dep_name" == "null" || "$dep_source" == "null" ]]; then
                  echo "‚ö†Ô∏è Skipping invalid dependency entry: $dep_entry"
                  continue
                fi

                echo "‚§¥Ô∏è Processing dependency entry: name='$dep_name' source='$dep_source'"

                # Determine version for this dependency source
                src_version=""
                
                if [[ "$dep_source" == "${GITHUB_REPOSITORY##*/}" ]]; then
                  # If the dependency source is the current repo, reuse current VERSION
                  echo "   ‚Ü™ Source '$dep_source' is current repo ‚Üí using local version: $VERSION"
                  src_version="$VERSION"
                else
                  # Otherwise fetch from GitHub (try same branch, fallback to master/main)
                  for b in "$BRANCH_NAME" master main; do
                    echo "   ‚Ü™ Trying to fetch version from https://github.com/chetanpatil018/$dep_source/blob/$b/pom.xml?raw=true"
                    http_status=$(curl -s -o /tmp/_pom.xml -w "%{http_code}" "https://github.com/chetanpatil018/$dep_source/blob/$b/pom.xml?raw=true" || echo "000")
                    if [[ "$http_status" == "200" && -s /tmp/_pom.xml ]]; then
                      src_version=$(xmlstarlet sel -t -v "/_:project/_:version" /tmp/_pom.xml 2>/dev/null || echo "")
                      echo "     ‚Ü™ Found pom on branch '$b' (http $http_status) ‚Üí version='$src_version'"
                      break
                    else
                      echo "     ‚Ü™ Not found on branch '$b' (http $http_status)"
                    fi
                  done
                fi

                if [[ -z "$src_version" ]]; then
                  echo "‚ö†Ô∏è Could not fetch version from repo '$dep_source' on branches [$BRANCH_NAME, master, main] ‚Äî skipping $dep_name"
                  continue
                fi

                # Update property or dependency in the dependent's pom
                if [[ "$dep_name" == *"."* ]]; then
                  # Use local-name() so dotted property names (e.g., common.version) are handled properly even with namespaces
                  echo "   ‚Ü™ Updating property <$dep_name> ‚Üí $src_version"
                  xmlstarlet ed -L -u "/_:project/_:properties/*[local-name()='$dep_name']" -v "$src_version" pom.xml \
                    || echo "‚ö†Ô∏è Failed to update property $dep_name"
                else
                  echo "   ‚Ü™ Updating dependency artifactId '$dep_name' ‚Üí $src_version"
                  xmlstarlet ed -L -u "//_:dependency[_:artifactId='$dep_name']/_:version" -v "$src_version" pom.xml \
                    || echo "‚ö†Ô∏è Failed to update dependency $dep_name"
                fi
              done
            fi

            # Extract current version safely for patch increment (use xmlstarlet first)
            current_version=$(xmlstarlet sel -t -v "/_:project/_:version" pom.xml 2>/dev/null || echo "")
            if [[ -z "$current_version" ]]; then
              current_version=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout 2>/dev/null || echo "")
            fi

            if [[ -z "$current_version" ]]; then
              echo "‚ùå Could not determine current version for $repo"
              cd ..
              rm -rf $repo
              continue
            fi

            echo "Current version in $repo: $current_version"

            # Compute next patch version
            base_version=$(echo "$current_version" | sed 's/-SNAPSHOT//')
            major=$(echo "$base_version" | cut -d. -f1)
            minor=$(echo "$base_version" | cut -d. -f2)
            patch=$(echo "$base_version" | cut -d. -f3)
            next_patch=$((patch + 1))
            next_version="${major}.${minor}.${next_patch}"

            if [[ "$BRANCH_NAME" != "master" ]]; then
              next_version="${next_version}-SNAPSHOT"
            fi

            echo "üîß Bumping $repo to $next_version"
            mvn versions:set -DnewVersion=$next_version -DgenerateBackupPoms=false

            # Commit & push changes if any
            git add pom.xml
            if git diff --cached --quiet; then
              echo "No changes to commit in $repo"
            else
              git commit -m "Bump version to $next_version and update dependencies using their source repos [skip ci]"
              git push origin "$BRANCH_NAME"
            fi

            cd ..

            # Trigger workflow_dispatch for dependent repo
            echo "Triggering workflow_dispatch for $repo"
            curl -s -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer $GH_TOKEN" \
              https://api.github.com/repos/chetanpatil018/$repo/actions/workflows/main.yml/dispatches \
              -d "{\"ref\":\"$BRANCH_NAME\"}" \
              || echo "‚ö†Ô∏è workflow_dispatch failed for $repo"

            # Clean up cloned repo
            rm -rf $repo
          done
